"use strict";
//////////////// Генерация пользовательских событий ////////////

// Можно не только назначать обработчики, но и генерировать события из JavaScript-кода.
// Пользовательские события могут быть использованы при создании графических компонентов. 
// Например, корневой элемент нашего меню, реализованного при помощи JavaScript, может генерировать события, 
// относящиеся к этому меню: open (меню раскрыто), select (выбран пункт меню) и т.п. 
// А другой код может слушать эти события и узнавать, что происходит с меню.
// Можно генерировать не только совершенно новые, придуманные нами события, 
// но и встроенные, такие как click, mousedown и другие.

// Конструктор Event
// Встроенные классы для событий формируют иерархию аналогично классам для DOM-элементов. Её корнем является встроенный класс Event.

// let event = new Event(type[options]);

// type – тип события, строка, например "click" или же любой придуманный нами – "my-event".
// options – объект с тремя необязательными свойствами:
// bubbles: true/false – если true, тогда событие всплывает.
// cancelable: true/false – если true, тогда можно отменить действие по умолчанию. Позже мы разберём, что это значит для пользовательских событий.
// composed: true/false – если true, тогда событие будет всплывать наружу за пределы Shadow DOM. Позже мы разберём это в разделе Веб-компоненты.

// По умолчанию все три свойства установлены в false: {bubbles: false, cancelable: false, composed: false}.


// MouseEvent, KeyboardEvent и другие
// Для некоторых конкретных типов событий есть свои специфические конструкторы.

// UIEvent
// FocusEvent
// MouseEvent
// WheelEvent
// KeyboardEvent


// Пользовательские события
// Для генерации событий совершенно новых типов, таких как "hello", следует использовать конструктор new CustomEvent. 
// Технически CustomEvent абсолютно идентичен Event за исключением одной небольшой детали.
// У второго аргумента-объекта есть дополнительное свойство detail, в котором можно указывать информацию для передачи в событие.

// event.preventDefault()
// Для многих браузерных событий есть «действия по умолчанию», такие как переход по ссылке, выделение и т.п.
// Для новых, пользовательских событий браузерных действий, конечно, нет, но код, 
// который генерирует такое событие, может предусматривать какие-то свои действия после события.

// Итого
// Чтобы сгенерировать событие из кода, вначале надо создать объект события.

// Базовый конструктор Event(name, options) принимает обязательное имя события и options – объект с двумя свойствами:

// bubbles: true чтобы событие всплывало.
// cancelable: true если мы хотим, чтобы event.preventDefault() работал.
// Особые конструкторы встроенных событий MouseEvent, KeyboardEvent и другие принимают специфичные для каждого конкретного типа событий свойства. Например, clientX для событий мыши.

// Для пользовательских событий стоит применять конструктор CustomEvent. У него есть дополнительная опция detail, с помощью которой можно передавать информацию в объекте события. После чего все обработчики смогут получить к ней доступ через event.detail.

// Несмотря на техническую возможность генерировать встроенные браузерные события типа click или keydown, пользоваться ей стоит с большой осторожностью.

// Весьма часто, когда разработчик хочет сгенерировать встроенное событие – это вызвано «кривой» архитектурой кода.

// Как правило, генерация встроенных событий полезна в следующих случаях:

// Либо как явный и грубый хак, чтобы заставить работать сторонние библиотеки, в которых не предусмотрены другие средства взаимодействия.
// Либо для автоматического тестирования, чтобы скриптом «нажать на кнопку» и посмотреть, произошло ли нужное действие.
// Пользовательские события со своими именами часто создают для улучшения архитектуры, чтобы сообщить о том, что происходит внутри наших меню, слайдеров, каруселей и т.д.


// Всплытие и погружение

// Всплытие
// Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.

{/* <style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form> */}


// event.target
// Всегда можно узнать, на каком конкретно элементе произошло событие.
// Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.

// Отличия от this (=event.currentTarget):
// event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
// this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.