"use strict"
///////////////////// Генераторы //////////////////////

// Обычные функции возвращают только одно-единственное значение (или ничего).
// Генераторы могут порождать (yield) множество значений одно за другим, по мере необходимости. 
// Генераторы отлично работают с перебираемыми объектами и позволяют легко создавать потоки данных.

// Для объявления генератора используется специальная синтаксическая конструкция: 
// function*, которая называется «функция-генератор».

function* generateSequence() {
  yield 1;
  yield 2;
  return 3;
}

// Функции-генераторы ведут себя не так, как обычные. Когда такая функция вызвана, она не выполняет свой код. 
// Вместо этого она возвращает специальный объект, так называемый «генератор», для управления её выполнением.

// "функция-генератор" создаёт объект "генератор"
const generator = generateSequence();
console.log(generator);

// Основным методом генератора является next(). 
// При вызове он запускает выполнение кода до ближайшей инструкции yield <значение> 
// (значение может отсутствовать, в этом случае оно предполагается равным undefined). 
// По достижении yield выполнение функции приостанавливается, 
// а соответствующее значение – возвращается во внешний код:

// Результатом метода next() всегда является объект с двумя свойствами:

// value: значение из yield.
// done: true, если выполнение функции завершено, иначе false.

// Здесь мы создаём генератор и получаем первое из возвращаемых им значений:
const one = generator.next();
console.log(one); // {value: 1, done: false}
console.log(JSON.stringify(one)); // {"value":1,"done":false}

// Повторный вызов generator.next() возобновит выполнение кода и вернёт результат следующего yield:
const two = generator.next();
console.log(two); // {value: 2, done: false}
console.log(JSON.stringify(two)); // {"value":2,"done":false}

// И, наконец, последний вызов завершит выполнение функции и вернёт результат return:
const three = generator.next();
console.log(three); // {value: 3, done: true}
console.log(JSON.stringify(three)); // {"value":3,"done":true}

// Сейчас генератор полностью выполнен. 
// Мы можем увидеть это по свойству done:true и обработать value:3 как окончательный результат.
// Новые вызовы generator.next() больше не имеют смысла. Впрочем, если они и будут, то не вызовут ошибки, 
// но будут возвращать один и тот же объект: {done: true}


// Перебор генераторов
// Как вы, наверное, уже догадались по наличию метода next(), генераторы являются перебираемыми объектами.
// Возвращаемые ими значения можно перебирать через for..of:

for(let value of generator) {
  // console.log(value); Перебор не сработате, если гениратор уже вызван через next();
}


function* generationNumber() {
  yield 1;
  yield 2;
  yield 3;
  return 4;
}

const generationNum = generationNumber();

for(let value of generationNum) {
  console.log(value); // 1, 2, 3
}

// Так как генераторы являются перебираемыми объектами, 
// мы можем использовать всю связанную с ними функциональность, например оператор расширения ... :
function* generationString() {
  yield 'one';
  yield 'two';
  yield 'three';
};

// ..generateSequence() превращает перебираемый объект-генератор в массив элементов
const generationStr = ['zero', ...generationString(), 'four'];
for(let value of generationStr) {
  console.log(value); // zero, one, two, three, four
}


// Использование генераторов для перебираемых объектов
// Мы можем использовать функцию-генератор для итерации, указав её в Symbol.iterator.

const renge = {
  from: 1,
  to: 5,

  *[Symbol.iterator] () { // краткая запись для [Symbol.iterator]: function*()
    for(let value = this.from; value <= this.to; value++) {
      yield value;
    }
  }

};

console.log(...renge); // 1 2 3 4 5


// Композиция генераторов

// Композиция генераторов – это особенная возможность генераторов, 
// которая позволяет прозрачно «встраивать» генераторы друг в друга.

// функция для генерации последовательности чисел:
function* generationsSequence(start, end) {
  for ( let i = start; i < end; i++) {
    yield i;
  }
};

// Для генераторов есть особый синтаксис yield*, 
// который позволяет «вкладывать» генераторы один в другой (осуществлять их композицию).
function* generatePasswordCode() {
  // 0...9
  yield* generationsSequence(48, 57);

  // A...Z
  yield* generationsSequence(65, 90);

  // a...z
  yield* generationsSequence(97, 122);
}

let str = '';
for(let code of generatePasswordCode()) {
  str += String.fromCharCode(code);
}

console.log(`srt : `,str); // 012345678ABCDEFGHIJKLMNOPQRSTUVWXYabcdefghijklmnopqrstuvwxy

// Директива yield* делегирует выполнение другому генератору. 
// Этот термин означает, что yield* gen перебирает генератор gen и прозрачно направляет его вывод наружу. 
// Как если бы значения были сгенерированы внешним генератором.

// Композиция генераторов – естественный способ вставлять вывод одного генератора в поток другого. 
// Она не использует дополнительную память для хранения промежуточных результатов.


// yield – дорога в обе стороны

// До этого момента генераторы сильно напоминали перебираемые объекты, со специальным синтаксисом для генерации значений. 
// Но на самом деле они намного мощнее и гибче.
// Всё дело в том, что yield – дорога в обе стороны: он не только возвращает результат наружу, 
// но и может передавать значение извне в генератор.
// Чтобы это сделать, нам нужно вызвать generator.next(arg) с аргументом. Этот аргумент становится результатом yield.

function* gen() {
  // Передаём вопрос во внешний код и ожидаем ответа
  let result = yield "2 + 2 = ?";
  alert(result);
}

let generatorSum = gen();
let question = generatorSum.next().value; // <-- yield возвращает значение

generatorSum.next(4);


// Генераторы создаются при помощи функций-генераторов function* f(…) {…}.
// Внутри генераторов и только внутри них существует оператор yield.
// Внешний код и генератор обмениваются промежуточными результатами посредством вызовов next/yield.
// В современном JavaScript генераторы используются редко. Но иногда они оказываются полезными, 
// потому что способность функции обмениваться данными с вызывающим кодом во время выполнения совершенно уникальна. 
// И, конечно, для создания перебираемых объектов.


////////////////////////////////////////////////////////
function* pseudoRandom(seed) {
  let value = seed;

  while(true) {
    value = value * 16807 % 2147483647
    yield value;
  }

};

let generatorRandom = pseudoRandom(1);

alert(generatorRandom.next().value); // 16807
alert(generatorRandom.next().value); // 282475249
alert(generatorRandom.next().value); // 1622650073

// то же самое можно сделать с помощью обычной функции
function pseudoRandom_(seed) {
  let value = seed;

  return function() {
    value = value * 16807 % 2147483647;
    return value;
  }
}

let generator_ = pseudoRandom_(1);

alert(generator_()); // 16807
alert(generator_()); // 282475249
alert(generator_()); // 1622650073

// Это также работает. Но тогда мы потеряем возможность перебора с помощью for..of и 
// использования композиции генераторов, которая тоже может быть полезна.