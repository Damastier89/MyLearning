"use strict"

// Промисы: обработка ошибок

// Цепочки промисов отлично подходят для перехвата ошибок. 
// Если промис завершается с ошибкой, то управление переходит в ближайший обработчик ошибок.

fetch(`https://exemple-test.ss`)
  .then(response => response.json())
  .catch(err => console.log(new Error(`${err}. Whooops o_O`))); // Error: TypeError: Failed to fetch. Whooops o_O

// Как видно, .catch не обязательно должен быть сразу после ошибки, 
// он может быть далее, после одного или даже нескольких .then

// Или, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON. 
// Самый лёгкий путь перехватить все ошибки – это добавить .catch в конец цепочки(строка 103)

// Если все в порядке, то такой .catch вообще не выполнится. 
// Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.


// Неявный try…catch

// Вокруг функции промиса и обработчиков находится "невидимый try..catch". 
// Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой

new Promise((resolve, reject) => {
  throw new Error(`Error o_O`);
}).catch(err => console.log(err));

// …Работает так же, как и этот:

new Promise((resolve, reject) => {
  reject(new Error(`Error o_O`));
}).catch(err => console.log(err));

// "Невидимый try..catch" вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.


// Пробрасывание ошибок

new Promise((resolve, reject) => {
  throw new Error("Ошибка!");
}).catch(function(error) {
  console.log("Ошибка обработана, продолжить работу");
}).then(() => console.log("Управление перейдёт в следующий then"));

// Здесь блок .catch завершается нормально. Поэтому вызывается следующий успешный обработчик .then.

// В примере ниже мы видим другую ситуацию с блоком .catch. 
// Обработчик (*) перехватывает ошибку и не может обработать её 
// (например, он знает как обработать только URIError), поэтому ошибка пробрасывается далее:

new Promise((resolve, reject) => {
  throw new Error("Ошибка!");
}).catch(function(error) { // (*)
  if (error instanceof URIError) {
    // обрабатываем ошибку
  } else {
    console.log("Не могу обработать ошибку");
    throw error; // пробрасывает эту или другую ошибку в следующий catch
  }
}).then(function() {
  /* не выполнится */
}).catch(error => { // (**)
  console.log(`Неизвестная ошибка: ${error}`);
  // ничего не возвращаем => выполнение продолжается в нормальном режиме
});

// Управление переходит от первого блока .catch (*) к следующему (**), вниз по цепочке.

// Необработанные ошибки

// Что произойдёт, если ошибка не будет обработана? 
// Например, мы просто забыли добавить .catch в конец цепочки.

new Promise(function() {
  noSuchFunction(); // Ошибка (нет такой функции)
})
  .then(() => {
    // обработчики .then, один или более
  }); // без .catch в самом конце!

// В случае ошибки выполнение должно перейти к ближайшему обработчику ошибок. Но в примере выше нет никакого обработчика. Поэтому ошибка как бы «застревает», её некому обработать.
// На практике, как и при обычных необработанных ошибках в коде, это означает, что что-то пошло сильно не так.
// Что происходит, когда обычная ошибка не перехвачена try..catch? Скрипт умирает с сообщением в консоли. Похожее происходит и в случае необработанной ошибки промиса.
// JavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку. Вы можете увидеть её в консоли, если запустите пример выше.
// В браузере мы можем поймать такие ошибки, используя событие unhandledrejection:


window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  console.log(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  console.log(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});

new Promise(function() {
  throw new Error("Ошибка!");
}); // нет обработчика ошибок

// Это событие является частью стандарта HTML.
// Если происходит ошибка, и отсутствует её обработчик, то генерируется событие unhandledrejection, и соответствующий объект event содержит информацию об ошибке.
// Обычно такие ошибки неустранимы, поэтому лучше всего – информировать пользователя о проблеме и, возможно, отправить информацию об ошибке на сервер.
// В не-браузерных средах, таких как Node.js, есть другие способы отслеживания необработанных ошибок.